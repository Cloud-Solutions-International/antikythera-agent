<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/sa/com/cloudsolutions/antikythera/agent/AntikytheraAgent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/sa/com/cloudsolutions/antikythera/agent/AntikytheraAgent.java" />
              <option name="originalContent" value="package sa.com.cloudsolutions.antikythera.agent;&#10;&#10;import net.bytebuddy.agent.ByteBuddyAgent;&#10;import net.bytebuddy.agent.builder.AgentBuilder;&#10;import net.bytebuddy.asm.AsmVisitorWrapper;&#10;import net.bytebuddy.asm.Advice;&#10;import net.bytebuddy.description.field.FieldDescription;&#10;import net.bytebuddy.description.field.FieldList;&#10;import net.bytebuddy.description.method.MethodList;&#10;import net.bytebuddy.description.type.TypeDescription;&#10;import net.bytebuddy.dynamic.ClassFileLocator;&#10;import net.bytebuddy.implementation.Implementation;&#10;import net.bytebuddy.matcher.ElementMatcher;&#10;import net.bytebuddy.matcher.ElementMatchers;&#10;import net.bytebuddy.pool.TypePool;&#10;import net.bytebuddy.jar.asm.ClassVisitor;&#10;import net.bytebuddy.jar.asm.MethodVisitor;&#10;import net.bytebuddy.jar.asm.Opcodes;&#10;&#10;import java.lang.instrument.Instrumentation;&#10;import java.util.Collections;&#10;&#10;/**&#10; * Java agent that installs a Byte Buddy transformation to classes that declare a field named&#10; * &quot;instanceInterceptor&quot;. For such classes, after any successful field write (PUTFIELD/PUTSTATIC)&#10; * inside an instance method, we invoke Support.afterSet(this, fieldName, null).&#10; *&#10; * Additionally, we intercept reflective writes via java.lang.reflect.Field#set*(Object, ...)&#10; * and perform the same callback after successful completion.&#10; *&#10; * The agent can be installed via premain/agentmain or programmatically by calling initialize().&#10; */&#10;public class AntikytheraAgent {&#10;&#10;    public static void premain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    public static void agentmain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    /**&#10;     * Allows runtime installation without -javaagent by attaching a Byte Buddy agent to the current JVM&#10;     * and then registering our transformers on the returned Instrumentation.&#10;     */&#10;    public static void initialize() {&#10;        Instrumentation inst = ByteBuddyAgent.install();&#10;        install(inst);&#10;    }&#10;&#10;    private static void install(Instrumentation inst) {&#10;        ElementMatcher.Junction&lt;TypeDescription&gt; typeMatcher =&#10;                ElementMatchers.declaresField(ElementMatchers.named(&quot;instanceInterceptor&quot;));&#10;&#10;        try {&#10;            // Manually append ReflectiveSetAdvice to bootstrap classloader&#10;            ClassFileLocator locator = ClassFileLocator.ForClassLoader.of(AntikytheraAgent.class.getClassLoader());&#10;            byte[] adviceClass = locator.locate(ReflectiveSetAdvice.class.getName()).resolve();&#10;&#10;            // Create a temporary JAR file containing the advice class&#10;            java.io.File tempJar = java.io.File.createTempFile(&quot;antikythera-agent-advice&quot;, &quot;.jar&quot;);&#10;            tempJar.deleteOnExit();&#10;&#10;            try (java.util.jar.JarOutputStream jos = new java.util.jar.JarOutputStream(&#10;                    new java.io.FileOutputStream(tempJar))) {&#10;                java.util.jar.JarEntry entry = new java.util.jar.JarEntry(&#10;                        ReflectiveSetAdvice.class.getName().replace('.', '/') + &quot;.class&quot;);&#10;                jos.putNextEntry(entry);&#10;                jos.write(adviceClass);&#10;                jos.closeEntry();&#10;            }&#10;&#10;            // Add to bootstrap classloader&#10;            inst.appendToBootstrapClassLoaderSearch(new java.util.jar.JarFile(tempJar));&#10;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to inject ReflectiveSetAdvice into bootstrap classloader&quot;, e);&#10;        }&#10;&#10;        new AgentBuilder.Default()&#10;                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)&#10;                .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)&#10;                .with(AgentBuilder.TypeStrategy.Default.REDEFINE)&#10;                .ignore(ElementMatchers.none())&#10;                .type(typeMatcher)&#10;                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt;&#10;                        builder.visit(createFieldWriteHook()))&#10;                .type(ElementMatchers.named(&quot;java.lang.reflect.Field&quot;))&#10;                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt;&#10;                        builder.visit(Advice.to(ReflectiveSetAdvice.class).on(&#10;                                ElementMatchers.named(&quot;set&quot;)&#10;                                        .or(ElementMatchers.named(&quot;setBoolean&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setByte&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setChar&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setShort&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setInt&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setLong&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setFloat&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setDouble&quot;))&#10;                        )))&#10;                .installOn(inst);&#10;        try {&#10;            inst.retransformClasses(java.lang.reflect.Field.class);&#10;        } catch (Exception e) {&#10;            System.out.println(&quot;Failed to retransform Field: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private static AsmVisitorWrapper createFieldWriteHook() {&#10;        return new net.bytebuddy.asm.AsmVisitorWrapper.AbstractBase() {&#10;            @Override&#10;            public ClassVisitor wrap(TypeDescription instrumentedType,&#10;                                     ClassVisitor classVisitor,&#10;                                     Implementation.Context implementationContext,&#10;                                     TypePool typePool,&#10;                                     FieldList&lt;FieldDescription.InDefinedShape&gt; fields,&#10;                                     MethodList&lt;?&gt; methods,&#10;                                     int writerFlags,&#10;                                     int readerFlags) {&#10;                return new ClassVisitor(Opcodes.ASM9, classVisitor) {&#10;                    @Override&#10;                    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {&#10;                        MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);&#10;                        final boolean isStatic = (access &amp; Opcodes.ACC_STATIC) != 0;&#10;                        return new MethodVisitor(Opcodes.ASM9, mv) {&#10;                            @Override&#10;                            public void visitFieldInsn(int opcode, String owner, String fieldName, String fieldDesc) {&#10;                                super.visitFieldInsn(opcode, owner, fieldName, fieldDesc);&#10;                                if (!isStatic &amp;&amp; (opcode == Opcodes.PUTFIELD || opcode == Opcodes.PUTSTATIC)) {&#10;                                    super.visitVarInsn(Opcodes.ALOAD, 0);&#10;                                    super.visitLdcInsn(fieldName);&#10;                                    super.visitInsn(Opcodes.ACONST_NULL);&#10;                                    super.visitMethodInsn(&#10;                                            Opcodes.INVOKESTATIC,&#10;                                            &quot;sa/com/cloudsolutions/antikythera/agent/Support&quot;,&#10;                                            &quot;afterSet&quot;,&#10;                                            &quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,&#10;                                            false&#10;                                    );&#10;                                }&#10;                            }&#10;                        };&#10;                    }&#10;                };&#10;            }&#10;        };&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package sa.com.cloudsolutions.antikythera.agent;&#10;&#10;import net.bytebuddy.agent.ByteBuddyAgent;&#10;import net.bytebuddy.agent.builder.AgentBuilder;&#10;import net.bytebuddy.asm.Advice;&#10;import net.bytebuddy.dynamic.ClassFileLocator;&#10;import net.bytebuddy.matcher.ElementMatchers;&#10;&#10;import java.lang.instrument.Instrumentation;&#10;&#10;/**&#10; * Java agent that intercepts reflective field writes via java.lang.reflect.Field#set*(Object, ...)&#10; * and updates the corresponding Symbol in the EvaluationEngine if the target object has an&#10; * instanceInterceptor field.&#10; *&#10; * The agent can be installed via premain/agentmain or programmatically by calling initialize().&#10; */&#10;public class AntikytheraAgent {&#10;&#10;    public static void premain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    public static void agentmain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    /**&#10;     * Allows runtime installation without -javaagent by attaching a Byte Buddy agent to the current JVM&#10;     * and then registering our transformers on the returned Instrumentation.&#10;     */&#10;    public static void initialize() {&#10;        Instrumentation inst = ByteBuddyAgent.install();&#10;        install(inst);&#10;    }&#10;&#10;    private static void install(Instrumentation inst) {&#10;        try {&#10;            // Manually append ReflectiveSetAdvice to bootstrap classloader&#10;            ClassFileLocator locator = ClassFileLocator.ForClassLoader.of(AntikytheraAgent.class.getClassLoader());&#10;            byte[] adviceClass = locator.locate(ReflectiveSetAdvice.class.getName()).resolve();&#10;&#10;            // Create a temporary JAR file containing the advice class&#10;            java.io.File tempJar = java.io.File.createTempFile(&quot;antikythera-agent-advice&quot;, &quot;.jar&quot;);&#10;            tempJar.deleteOnExit();&#10;&#10;            try (java.util.jar.JarOutputStream jos = new java.util.jar.JarOutputStream(&#10;                    new java.io.FileOutputStream(tempJar))) {&#10;                java.util.jar.JarEntry entry = new java.util.jar.JarEntry(&#10;                        ReflectiveSetAdvice.class.getName().replace('.', '/') + &quot;.class&quot;);&#10;                jos.putNextEntry(entry);&#10;                jos.write(adviceClass);&#10;                jos.closeEntry();&#10;            }&#10;&#10;            // Add to bootstrap classloader&#10;            inst.appendToBootstrapClassLoaderSearch(new java.util.jar.JarFile(tempJar));&#10;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to inject ReflectiveSetAdvice into bootstrap classloader&quot;, e);&#10;        }&#10;&#10;        new AgentBuilder.Default()&#10;                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)&#10;                .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)&#10;                .with(AgentBuilder.TypeStrategy.Default.REDEFINE)&#10;                .ignore(ElementMatchers.none())&#10;                // Only instrument java.lang.reflect.Field for reflective field sets&#10;                .type(ElementMatchers.named(&quot;java.lang.reflect.Field&quot;))&#10;                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt;&#10;                        builder.visit(Advice.to(ReflectiveSetAdvice.class).on(&#10;                                ElementMatchers.named(&quot;set&quot;)&#10;                                        .or(ElementMatchers.named(&quot;setBoolean&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setByte&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setChar&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setShort&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setInt&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setLong&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setFloat&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setDouble&quot;))&#10;                        )))&#10;                .installOn(inst);&#10;        try {&#10;            inst.retransformClasses(java.lang.reflect.Field.class);&#10;        } catch (Exception e) {&#10;            System.out.println(&quot;Failed to retransform Field: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/sa/com/cloudsolutions/antikythera/agent/ReflectiveSetAdvice.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/sa/com/cloudsolutions/antikythera/agent/ReflectiveSetAdvice.java" />
              <option name="originalContent" value="package sa.com.cloudsolutions.antikythera.agent;&#10;&#10;import net.bytebuddy.asm.Advice;&#10;import net.bytebuddy.implementation.bytecode.assign.Assigner;&#10;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Method;&#10;&#10;/**&#10; * Advice that runs after reflective field set operations. It uses only JDK reflection&#10; * to avoid class loader issues when instrumenting a bootstrap class.&#10; */&#10;public class ReflectiveSetAdvice {&#10;&#10;    /**&#10;     * ThreadLocal flag to track if we're currently inside an agent-originated call.&#10;     * This prevents infinite recursion when our callbacks trigger more reflective operations.&#10;     */&#10;    private static final ThreadLocal&lt;Boolean&gt; IN_AGENT_CALL = ThreadLocal.withInitial(() -&gt; false);&#10;&#10;    @Advice.OnMethodExit(onThrowable = Throwable.class)&#10;    public static void after(&#10;            @Advice.This Field self,&#10;            @Advice.Argument(0) Object target,&#10;            @Advice.Argument(value = 1, typing = Assigner.Typing.DYNAMIC) Object value,&#10;            @Advice.Thrown Throwable thrown&#10;    ) {&#10;        // Prevent recursive interception from agent-originated calls&#10;        if (IN_AGENT_CALL.get()) return;&#10;&#10;        if (thrown != null) return; // only after successful sets&#10;        if (target == null) return; // static fields not supported (no instanceInterceptor)&#10;        if (self == null || self.getName().equals(&quot;instanceInterceptor&quot;) ) return;&#10;&#10;        // Mark that we're entering an agent call to prevent recursion&#10;        IN_AGENT_CALL.set(true);&#10;        try {&#10;            // Find 'instanceInterceptor' field up the hierarchy&#10;            Class&lt;?&gt; t = target.getClass();&#10;            Field interceptorField = null;&#10;            while (t != null &amp;&amp; t != Object.class) {&#10;                try {&#10;                    interceptorField = t.getDeclaredField(&quot;instanceInterceptor&quot;);&#10;                    break;&#10;                } catch (NoSuchFieldException e) {&#10;                    t = t.getSuperclass();&#10;                }&#10;            }&#10;            if (interceptorField != null) {&#10;                interceptorField.setAccessible(true);&#10;                Object methodInterceptor = interceptorField.get(target);&#10;                if (methodInterceptor != null) {&#10;                    // Get 'evaluator' field from MethodInterceptor&#10;                    Field evaluatorField = null;&#10;                    Class&lt;?&gt; miClass = methodInterceptor.getClass();&#10;                    while (miClass != null &amp;&amp; miClass != Object.class) {&#10;                        try {&#10;                            evaluatorField = miClass.getDeclaredField(&quot;evaluator&quot;);&#10;                            break;&#10;                        } catch (NoSuchFieldException e) {&#10;                            miClass = miClass.getSuperclass();&#10;                        }&#10;                    }&#10;                    if (evaluatorField != null) {&#10;                        evaluatorField.setAccessible(true);&#10;                        Object evaluator = evaluatorField.get(methodInterceptor);&#10;                        if (evaluator != null) {&#10;                            // Use reflection to call getField(String) on the evaluator (EvaluationEngine)&#10;                            Method getFieldMethod = null;&#10;                            try {&#10;                                getFieldMethod = evaluator.getClass().getMethod(&quot;getField&quot;, String.class);&#10;                            } catch (NoSuchMethodException e) {&#10;                                getFieldMethod = evaluator.getClass().getDeclaredMethod(&quot;getField&quot;, String.class);&#10;                                getFieldMethod.setAccessible(true);&#10;                            }&#10;                            Object symbol = getFieldMethod.invoke(evaluator, self.getName());&#10;                            if (symbol != null) {&#10;                                // Use reflection to call setValue(Object) on the Symbol&#10;                                Method setValueMethod = null;&#10;                                try {&#10;                                    setValueMethod = symbol.getClass().getMethod(&quot;setValue&quot;, Object.class);&#10;                                } catch (NoSuchMethodException e) {&#10;                                    setValueMethod = symbol.getClass().getDeclaredMethod(&quot;setValue&quot;, Object.class);&#10;                                    setValueMethod.setAccessible(true);&#10;                                }&#10;                                setValueMethod.invoke(symbol, value);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (Throwable ignore) {&#10;            // never let reflective hook break application behavior&#10;        } finally {&#10;            // Always clear the flag when exiting&#10;            IN_AGENT_CALL.set(false);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package sa.com.cloudsolutions.antikythera.agent;&#10;&#10;import net.bytebuddy.asm.Advice;&#10;import net.bytebuddy.implementation.bytecode.assign.Assigner;&#10;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Method;&#10;&#10;/**&#10; * Advice that runs after reflective field set operations. It uses only JDK reflection&#10; * to avoid class loader issues when instrumenting a bootstrap class.&#10; */&#10;public class ReflectiveSetAdvice {&#10;&#10;    /**&#10;     * ThreadLocal flag to track if we're currently inside an agent-originated call.&#10;     * This prevents infinite recursion when our callbacks trigger more reflective operations.&#10;     * Must be public to be accessible from java.lang.reflect.Field (bootstrap module).&#10;     */&#10;    public static final ThreadLocal&lt;Boolean&gt; IN_AGENT_CALL = ThreadLocal.withInitial(() -&gt; false);&#10;&#10;    @Advice.OnMethodExit(onThrowable = Throwable.class)&#10;    public static void after(&#10;            @Advice.This Field self,&#10;            @Advice.Argument(0) Object target,&#10;            @Advice.Argument(value = 1, typing = Assigner.Typing.DYNAMIC) Object value,&#10;            @Advice.Thrown Throwable thrown&#10;    ) {&#10;        // Prevent recursive interception from agent-originated calls&#10;        if (IN_AGENT_CALL.get()) return;&#10;&#10;        if (thrown != null) return; // only after successful sets&#10;        if (target == null) return; // static fields not supported (no instanceInterceptor)&#10;        if (self == null || self.getName().equals(&quot;instanceInterceptor&quot;) ) return;&#10;&#10;        // Mark that we're entering an agent call to prevent recursion&#10;        IN_AGENT_CALL.set(true);&#10;        try {&#10;            // Find 'instanceInterceptor' field up the hierarchy&#10;            Class&lt;?&gt; t = target.getClass();&#10;            Field interceptorField = null;&#10;            while (t != null &amp;&amp; t != Object.class) {&#10;                try {&#10;                    interceptorField = t.getDeclaredField(&quot;instanceInterceptor&quot;);&#10;                    break;&#10;                } catch (NoSuchFieldException e) {&#10;                    t = t.getSuperclass();&#10;                }&#10;            }&#10;            if (interceptorField != null) {&#10;                interceptorField.setAccessible(true);&#10;                Object methodInterceptor = interceptorField.get(target);&#10;                if (methodInterceptor != null) {&#10;                    // Get 'evaluator' field from MethodInterceptor&#10;                    Field evaluatorField = null;&#10;                    Class&lt;?&gt; miClass = methodInterceptor.getClass();&#10;                    while (miClass != null &amp;&amp; miClass != Object.class) {&#10;                        try {&#10;                            evaluatorField = miClass.getDeclaredField(&quot;evaluator&quot;);&#10;                            break;&#10;                        } catch (NoSuchFieldException e) {&#10;                            miClass = miClass.getSuperclass();&#10;                        }&#10;                    }&#10;                    if (evaluatorField != null) {&#10;                        evaluatorField.setAccessible(true);&#10;                        Object evaluator = evaluatorField.get(methodInterceptor);&#10;                        if (evaluator != null) {&#10;                            // Use reflection to call getField(String) on the evaluator (EvaluationEngine)&#10;                            Method getFieldMethod = null;&#10;                            try {&#10;                                getFieldMethod = evaluator.getClass().getMethod(&quot;getField&quot;, String.class);&#10;                            } catch (NoSuchMethodException e) {&#10;                                getFieldMethod = evaluator.getClass().getDeclaredMethod(&quot;getField&quot;, String.class);&#10;                                getFieldMethod.setAccessible(true);&#10;                            }&#10;                            Object symbol = getFieldMethod.invoke(evaluator, self.getName());&#10;                            if (symbol != null) {&#10;                                // Use reflection to call setValue(Object) on the Symbol&#10;                                Method setValueMethod = null;&#10;                                try {&#10;                                    setValueMethod = symbol.getClass().getMethod(&quot;setValue&quot;, Object.class);&#10;                                } catch (NoSuchMethodException e) {&#10;                                    setValueMethod = symbol.getClass().getDeclaredMethod(&quot;setValue&quot;, Object.class);&#10;                                    setValueMethod.setAccessible(true);&#10;                                }&#10;                                setValueMethod.invoke(symbol, value);&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (Throwable ignore) {&#10;            // never let reflective hook break application behavior&#10;        } finally {&#10;            // Always clear the flag when exiting&#10;            IN_AGENT_CALL.set(false);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>