<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/sa/com/cloudsolutions/antikythera/agent/AntikytheraAgent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/sa/com/cloudsolutions/antikythera/agent/AntikytheraAgent.java" />
              <option name="originalContent" value="package sa.com.cloudsolutions.antikythera.agent;&#10;&#10;import net.bytebuddy.agent.ByteBuddyAgent;&#10;import net.bytebuddy.agent.builder.AgentBuilder;&#10;import net.bytebuddy.asm.AsmVisitorWrapper;&#10;import net.bytebuddy.asm.Advice;&#10;import net.bytebuddy.description.field.FieldDescription;&#10;import net.bytebuddy.description.field.FieldList;&#10;import net.bytebuddy.description.method.MethodList;&#10;import net.bytebuddy.description.type.TypeDescription;&#10;import net.bytebuddy.implementation.Implementation;&#10;import net.bytebuddy.implementation.bytecode.assign.Assigner;&#10;import net.bytebuddy.matcher.ElementMatcher;&#10;import net.bytebuddy.matcher.ElementMatchers;&#10;import net.bytebuddy.pool.TypePool;&#10;import net.bytebuddy.jar.asm.ClassVisitor;&#10;import net.bytebuddy.jar.asm.MethodVisitor;&#10;import net.bytebuddy.jar.asm.Opcodes;&#10;&#10;import java.lang.instrument.Instrumentation;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Method;&#10;&#10;/**&#10; * Java agent that installs a Byte Buddy transformation to classes that declare a field named&#10; * &quot;instanceInterceptor&quot;. For such classes, after any successful field write (PUTFIELD/PUTSTATIC)&#10; * inside an instance method, we invoke Support.afterSet(this, fieldName, null).&#10; *&#10; * Additionally, we intercept reflective writes via java.lang.reflect.Field#set*(Object, ...)&#10; * and perform the same callback after successful completion.&#10; *&#10; * The agent can be installed via premain/agentmain or programmatically by calling initialize().&#10; */&#10;public class AntikytheraAgent {&#10;&#10;    public static void premain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    public static void agentmain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    /**&#10;     * Allows runtime installation without -javaagent by attaching a Byte Buddy agent to the current JVM&#10;     * and then registering our transformers on the returned Instrumentation.&#10;     */&#10;    public static void initialize() {&#10;        Instrumentation inst = ByteBuddyAgent.install();&#10;        install(inst);&#10;    }&#10;&#10;    private static void install(Instrumentation inst) {&#10;        ElementMatcher.Junction&lt;TypeDescription&gt; typeMatcher =&#10;                ElementMatchers.declaresField(ElementMatchers.named(&quot;instanceInterceptor&quot;));&#10;&#10;        new AgentBuilder.Default()&#10;                .ignore(ElementMatchers.none()) // we restrict by the transformation matcher instead&#10;                // Instrument application classes that have an instanceInterceptor field&#10;                .type(typeMatcher)&#10;                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt;&#10;                        builder.visit(createFieldWriteHook()))&#10;                // Also instrument reflective sets performed through java.lang.reflect.Field&#10;                .type(ElementMatchers.named(&quot;java.lang.reflect.Field&quot;))&#10;                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt;&#10;                        builder.visit(Advice.to(ReflectiveSetAdvice.class).on(&#10;                                ElementMatchers.nameStartsWith(&quot;set&quot;)&#10;                                        .and(ElementMatchers.takesArguments(2))&#10;                                        .and(ElementMatchers.takesArgument(0, Object.class))&#10;                        )))&#10;                .installOn(inst);&#10;    }&#10;&#10;    private static AsmVisitorWrapper createFieldWriteHook() {&#10;        return new net.bytebuddy.asm.AsmVisitorWrapper.AbstractBase() {&#10;            @Override&#10;            public ClassVisitor wrap(TypeDescription instrumentedType,&#10;                                     ClassVisitor classVisitor,&#10;                                     Implementation.Context implementationContext,&#10;                                     TypePool typePool,&#10;                                     FieldList&lt;FieldDescription.InDefinedShape&gt; fields,&#10;                                     MethodList&lt;?&gt; methods,&#10;                                     int writerFlags,&#10;                                     int readerFlags) {&#10;                return new ClassVisitor(Opcodes.ASM9, classVisitor) {&#10;                    @Override&#10;                    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {&#10;                        MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);&#10;                        final boolean isStatic = (access &amp; Opcodes.ACC_STATIC) != 0;&#10;                        return new MethodVisitor(Opcodes.ASM9, mv) {&#10;                            @Override&#10;                            public void visitFieldInsn(int opcode, String owner, String fieldName, String fieldDesc) {&#10;                                super.visitFieldInsn(opcode, owner, fieldName, fieldDesc);&#10;                                if (!isStatic &amp;&amp; (opcode == Opcodes.PUTFIELD || opcode == Opcodes.PUTSTATIC)) {&#10;                                    super.visitVarInsn(Opcodes.ALOAD, 0);&#10;                                    super.visitLdcInsn(fieldName);&#10;                                    super.visitInsn(Opcodes.ACONST_NULL);&#10;                                    super.visitMethodInsn(&#10;                                            Opcodes.INVOKESTATIC,&#10;                                            &quot;sa/com/cloudsolutions/antikythera/agent/Support&quot;,&#10;                                            &quot;afterSet&quot;,&#10;                                            &quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,&#10;                                            false&#10;                                    );&#10;                                }&#10;                            }&#10;                        };&#10;                    }&#10;                };&#10;            }&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Advice that runs after reflective field set operations. It uses only JDK reflection&#10;     * to avoid class loader issues when instrumenting a bootstrap class.&#10;     */&#10;    public static class ReflectiveSetAdvice {&#10;        @Advice.OnMethodExit(onThrowable = Throwable.class)&#10;        public static void after(&#10;                @Advice.This Field self,&#10;                @Advice.Argument(0) Object target,&#10;                @Advice.Argument(value = 1, typing = Assigner.Typing.DYNAMIC) Object value,&#10;                @Advice.Thrown Throwable thrown&#10;        ) {&#10;            System.out.println(&quot;AFTER&quot;);&#10;&#10;            if (thrown != null) return; // only after successful sets&#10;            if (target == null) return; // static fields not supported (no instanceInterceptor)&#10;            try {&#10;                // Find 'instanceInterceptor' field up the hierarchy&#10;                Class&lt;?&gt; t = target.getClass();&#10;                java.lang.reflect.Field interceptorField = null;&#10;                while (t != null &amp;&amp; t != Object.class) {&#10;                    try {&#10;                        interceptorField = t.getDeclaredField(&quot;instanceInterceptor&quot;);&#10;                        break;&#10;                    } catch (NoSuchFieldException e) {&#10;                        t = t.getSuperclass();&#10;                    }&#10;                }&#10;                if (interceptorField == null) return;&#10;                interceptorField.setAccessible(true);&#10;                Object interceptor = interceptorField.get(target);&#10;                if (interceptor == null) return;&#10;&#10;                // Resolve setField(String, Symbol/any reference) method&#10;                Method setField;&#10;                try {&#10;                    Class&lt;?&gt; symbolClass = Class.forName(&quot;sa.com.cloudsolutions.antikythera.evaluator.Symbol&quot;);&#10;                    setField = interceptor.getClass().getMethod(&quot;setField&quot;, String.class, symbolClass);&#10;                } catch (Throwable ignore) {&#10;                    setField = null;&#10;                    for (Method m : interceptor.getClass().getMethods()) {&#10;                        if (!m.getName().equals(&quot;setField&quot;)) continue;&#10;                        Class&lt;?&gt;[] p = m.getParameterTypes();&#10;                        if (p.length == 2 &amp;&amp; p[0] == String.class &amp;&amp; !p[1].isPrimitive()) {&#10;                            setField = m;&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;                if (setField == null) return;&#10;                setField.setAccessible(true);&#10;                // We pass null for Symbol value to avoid dependency, consistent with direct write hook&#10;                setField.invoke(interceptor, self.getName(), null);&#10;            } catch (Throwable ignore) {&#10;                // never let reflective hook break application behavior&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package sa.com.cloudsolutions.antikythera.agent;&#10;&#10;import net.bytebuddy.agent.ByteBuddyAgent;&#10;import net.bytebuddy.agent.builder.AgentBuilder;&#10;import net.bytebuddy.asm.AsmVisitorWrapper;&#10;import net.bytebuddy.asm.Advice;&#10;import net.bytebuddy.description.field.FieldDescription;&#10;import net.bytebuddy.description.field.FieldList;&#10;import net.bytebuddy.description.method.MethodList;&#10;import net.bytebuddy.description.type.TypeDescription;&#10;import net.bytebuddy.implementation.Implementation;&#10;import net.bytebuddy.implementation.bytecode.assign.Assigner;&#10;import net.bytebuddy.matcher.ElementMatcher;&#10;import net.bytebuddy.matcher.ElementMatchers;&#10;import net.bytebuddy.pool.TypePool;&#10;import net.bytebuddy.jar.asm.ClassVisitor;&#10;import net.bytebuddy.jar.asm.MethodVisitor;&#10;import net.bytebuddy.jar.asm.Opcodes;&#10;&#10;import java.lang.instrument.Instrumentation;&#10;import java.lang.reflect.Field;&#10;import java.lang.reflect.Method;&#10;&#10;/**&#10; * Java agent that installs a Byte Buddy transformation to classes that declare a field named&#10; * &quot;instanceInterceptor&quot;. For such classes, after any successful field write (PUTFIELD/PUTSTATIC)&#10; * inside an instance method, we invoke Support.afterSet(this, fieldName, null).&#10; *&#10; * Additionally, we intercept reflective writes via java.lang.reflect.Field#set*(Object, ...)&#10; * and perform the same callback after successful completion.&#10; *&#10; * The agent can be installed via premain/agentmain or programmatically by calling initialize().&#10; */&#10;public class AntikytheraAgent {&#10;&#10;    public static void premain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    public static void agentmain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    /**&#10;     * Allows runtime installation without -javaagent by attaching a Byte Buddy agent to the current JVM&#10;     * and then registering our transformers on the returned Instrumentation.&#10;     */&#10;    public static void initialize() {&#10;        Instrumentation inst = ByteBuddyAgent.install();&#10;        install(inst);&#10;    }&#10;&#10;    private static void install(Instrumentation inst) {&#10;        ElementMatcher.Junction&lt;TypeDescription&gt; typeMatcher =&#10;                ElementMatchers.declaresField(ElementMatchers.named(&quot;instanceInterceptor&quot;));&#10;&#10;        new AgentBuilder.Default()&#10;                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)&#10;                .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)&#10;                .with(AgentBuilder.TypeStrategy.Default.REDEFINE)&#10;                .ignore(ElementMatchers.none())&#10;                .type(typeMatcher)&#10;                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt;&#10;                        builder.visit(createFieldWriteHook()))&#10;                .type(ElementMatchers.named(&quot;java.lang.reflect.Field&quot;))&#10;                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt;&#10;                        builder.visit(Advice.to(ReflectiveSetAdvice.class).on(&#10;                                ElementMatchers.named(&quot;set&quot;)&#10;                                        .or(ElementMatchers.named(&quot;setBoolean&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setByte&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setChar&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setShort&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setInt&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setLong&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setFloat&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setDouble&quot;))&#10;                        )))&#10;                .installOn(inst);&#10;    }&#10;&#10;    private static AsmVisitorWrapper createFieldWriteHook() {&#10;        return new net.bytebuddy.asm.AsmVisitorWrapper.AbstractBase() {&#10;            @Override&#10;            public ClassVisitor wrap(TypeDescription instrumentedType,&#10;                                     ClassVisitor classVisitor,&#10;                                     Implementation.Context implementationContext,&#10;                                     TypePool typePool,&#10;                                     FieldList&lt;FieldDescription.InDefinedShape&gt; fields,&#10;                                     MethodList&lt;?&gt; methods,&#10;                                     int writerFlags,&#10;                                     int readerFlags) {&#10;                return new ClassVisitor(Opcodes.ASM9, classVisitor) {&#10;                    @Override&#10;                    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {&#10;                        MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);&#10;                        final boolean isStatic = (access &amp; Opcodes.ACC_STATIC) != 0;&#10;                        return new MethodVisitor(Opcodes.ASM9, mv) {&#10;                            @Override&#10;                            public void visitFieldInsn(int opcode, String owner, String fieldName, String fieldDesc) {&#10;                                super.visitFieldInsn(opcode, owner, fieldName, fieldDesc);&#10;                                if (!isStatic &amp;&amp; (opcode == Opcodes.PUTFIELD || opcode == Opcodes.PUTSTATIC)) {&#10;                                    super.visitVarInsn(Opcodes.ALOAD, 0);&#10;                                    super.visitLdcInsn(fieldName);&#10;                                    super.visitInsn(Opcodes.ACONST_NULL);&#10;                                    super.visitMethodInsn(&#10;                                            Opcodes.INVOKESTATIC,&#10;                                            &quot;sa/com/cloudsolutions/antikythera/agent/Support&quot;,&#10;                                            &quot;afterSet&quot;,&#10;                                            &quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,&#10;                                            false&#10;                                    );&#10;                                }&#10;                            }&#10;                        };&#10;                    }&#10;                };&#10;            }&#10;        };&#10;    }&#10;&#10;    /**&#10;     * Advice that runs after reflective field set operations. It uses only JDK reflection&#10;     * to avoid class loader issues when instrumenting a bootstrap class.&#10;     */&#10;    public static class ReflectiveSetAdvice {&#10;        @Advice.OnMethodExit(onThrowable = Throwable.class)&#10;        public static void after(&#10;                @Advice.This Field self,&#10;                @Advice.Argument(0) Object target,&#10;                @Advice.Argument(value = 1, typing = Assigner.Typing.DYNAMIC) Object value,&#10;                @Advice.Thrown Throwable thrown&#10;        ) {&#10;            System.out.println(&quot;AFTER&quot;);&#10;&#10;            if (thrown != null) return; // only after successful sets&#10;            if (target == null) return; // static fields not supported (no instanceInterceptor)&#10;            try {&#10;                // Find 'instanceInterceptor' field up the hierarchy&#10;                Class&lt;?&gt; t = target.getClass();&#10;                java.lang.reflect.Field interceptorField = null;&#10;                while (t != null &amp;&amp; t != Object.class) {&#10;                    try {&#10;                        interceptorField = t.getDeclaredField(&quot;instanceInterceptor&quot;);&#10;                        break;&#10;                    } catch (NoSuchFieldException e) {&#10;                        t = t.getSuperclass();&#10;                    }&#10;                }&#10;                if (interceptorField == null) return;&#10;                interceptorField.setAccessible(true);&#10;                Object interceptor = interceptorField.get(target);&#10;                if (interceptor == null) return;&#10;&#10;                // Resolve setField(String, Symbol/any reference) method&#10;                Method setField;&#10;                try {&#10;                    Class&lt;?&gt; symbolClass = Class.forName(&quot;sa.com.cloudsolutions.antikythera.evaluator.Symbol&quot;);&#10;                    setField = interceptor.getClass().getMethod(&quot;setField&quot;, String.class, symbolClass);&#10;                } catch (Throwable ignore) {&#10;                    setField = null;&#10;                    for (Method m : interceptor.getClass().getMethods()) {&#10;                        if (!m.getName().equals(&quot;setField&quot;)) continue;&#10;                        Class&lt;?&gt;[] p = m.getParameterTypes();&#10;                        if (p.length == 2 &amp;&amp; p[0] == String.class &amp;&amp; !p[1].isPrimitive()) {&#10;                            setField = m;&#10;                            break;&#10;                        }&#10;                    }&#10;                }&#10;                if (setField == null) return;&#10;                setField.setAccessible(true);&#10;                // We pass null for Symbol value to avoid dependency, consistent with direct write hook&#10;                setField.invoke(interceptor, self.getName(), null);&#10;            } catch (Throwable ignore) {&#10;                // never let reflective hook break application behavior&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>