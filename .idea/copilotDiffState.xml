<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# Antikythera Agent&#10;&#10;A lightweight Java instrumentation agent (Java 21) that observes and propagates field write events for classes participating in the Antikythera evaluation/runtime model.&#10;&#10;The agent performs two complementary responsibilities:&#10;&#10;1. Bytecode field write hook: For every loaded/retransformed application class that declares a field named `instanceInterceptor`, the agent injects a callback after each successful field write (`PUTFIELD` or `PUTSTATIC`) executed inside an *instance* method. The injected callback is a static method call to `Support.afterSet(this, fieldName, null)`.&#10;2. Reflective write hook: It instruments the JDK class `java.lang.reflect.Field` so that after any reflective write via `Field#set*` methods, a reflective propagation routine (`ReflectiveSetAdvice`) locates the owning object's `instanceInterceptor` and ultimately updates an evaluation symbol representing the written field.&#10;&#10;&gt; The name &quot;Antikythera&quot; references the Antikythera mechanism: this agent helps keep an internal symbolic/evaluation model in sync with the evolving state of object instances.&#10;&#10;## Table of Contents&#10;- [When to Use](#when-to-use)&#10;- [Concepts](#concepts)&#10;- [How It Works](#how-it-works)&#10;  - [Class Selection](#class-selection)&#10;  - [ASM Injection Details](#asm-injection-details)&#10;  - [Reflective Advice Flow](#reflective-advice-flow)&#10;- [Runtime Attachment](#runtime-attachment)&#10;- [Build &amp; Install](#build--install)&#10;- [Using the Agent](#using-the-agent)&#10;  - [As a `-javaagent` Argument](#as-a--javaagent-argument)&#10;  - [Programmatic / Late Attachment](#programmatic--late-attachment)&#10;- [Integration Contract](#integration-contract)&#10;- [Limitations &amp; Edge Cases](#limitations--edge-cases)&#10;- [Performance Considerations](#performance-considerations)&#10;- [Security Considerations](#security-considerations)&#10;- [Testing](#testing)&#10;- [Extending the Agent](#extending-the-agent)&#10;- [Troubleshooting](#troubleshooting)&#10;- [Roadmap Ideas](#roadmap-ideas)&#10;&#10;## When to Use&#10;Use this agent if you need to:&#10;- Maintain a symbolic/evaluated representation (e.g., for scripting, live coding, or debugging) that mirrors the *current* field state of objects.&#10;- Capture ordinary bytecode field writes *and* reflective writes (`Field#set*`) without modifying application source.&#10;&#10;## Concepts&#10;| Term | Meaning |&#10;|------|---------|&#10;| `instanceInterceptor` | Marker field whose presence enrolls a class in instrumentation. Holds an object with an `evaluator` field. |&#10;| Evaluator | Object exposing a `getField(String)` method returning a Symbol. |&#10;| Symbol | Object exposing `setValue(Object)` and metadata (e.g., name). |&#10;| Support.afterSet | Static hook (not included here) expected to apply higher-level logic after a field change. |&#10;&#10;## How It Works&#10;### Class Selection&#10;`AntikytheraAgent` builds a Byte Buddy pipeline that:&#10;- Matches any type declaring a field literally named `instanceInterceptor`.&#10;- Applies an ASM visitor (`createFieldWriteHook`) to inject a post-write callback.&#10;- Separately targets `java.lang.reflect.Field` and applies `ReflectiveSetAdvice` to all `set`, `setXxx` primitive variants.&#10;&#10;### ASM Injection Details&#10;For each instrumented method:&#10;- Every encountered `PUTFIELD` or `PUTSTATIC` bytecode inside a non-static method triggers bytecode insertion *after* the original write.&#10;- Inserted sequence (simplified):&#10;  1. `ALOAD 0` (load `this`)&#10;  2. `LDC &lt;fieldName&gt;`&#10;  3. `ACONST_NULL` (placeholder value â€” downstream hook may re-read actual value if needed)&#10;  4. `INVOKESTATIC Support.afterSet(Object, String, Object)`&#10;&#10;Why `ACONST_NULL`? Avoids stack complexity and type-specific duplication; the real updated value can be reflectively resolved if the `Support` implementation requires it.&#10;&#10;### Reflective Advice Flow&#10;`ReflectiveSetAdvice.after(...)` runs on method exit of `Field#set*` if no exception occurred:&#10;1. Ignore static target writes (since `target == null`).&#10;2. Skip self-updates to the marker field (`instanceInterceptor`).&#10;3. Traverse the target's class hierarchy to find `instanceInterceptor`.&#10;4. From the interceptor object, locate its `evaluator` field.&#10;5. Call `evaluator.getField(fieldName)` to obtain a Symbol.&#10;6. Invoke `symbol.setValue(value)` with the just-written value.&#10;7. Swallow all throwables to preserve application stability.&#10;&#10;The advice deliberately uses *only* core reflection (no external library calls) to reduce risk when instrumenting a bootstrap class (`java.lang.reflect.Field`).&#10;&#10;## Runtime Attachment&#10;Two entry points are declared in the manifest (via shade &amp; jar plugins):&#10;- `Premain-Class` / `Agent-Class`: `sa.com.cloudsolutions.antikythera.agent.AntikytheraAgent`&#10;- Capabilities: class redefinition &amp; retransformation enabled (`Can-Redefine-Classes`, `Can-Retransform-Classes`).&#10;&#10;You can either:&#10;- Supply `-javaagent:/path/antikythera-agent-1.0-SNAPSHOT.jar` at JVM startup, or&#10;- Call `AntikytheraAgent.initialize()` inside a running JVM (Byte Buddy will self-attach using the attach API; tools.jar not required on modern JDKs).&#10;&#10;## Build &amp; Install&#10;Prerequisites: JDK 21, Maven 3.8+.&#10;&#10;Build shaded agent JAR:&#10;```&#10;mvn clean package&#10;```&#10;Output of interest:&#10;- `target/antikythera-agent-1.0-SNAPSHOT.jar` (shaded, manifest configured)&#10;&#10;## Using the Agent&#10;### As a `-javaagent` Argument&#10;```&#10;java -javaagent:./antikythera-agent-1.0-SNAPSHOT.jar -jar your-app.jar&#10;```&#10;All subsequently loaded matching classes will be instrumented. Already loaded matching classes may need either to be loaded after agent premain or require an explicit retransformation strategy (already enabled).&#10;&#10;### Programmatic / Late Attachment&#10;Embed (ensure the JAR is on the application classpath):&#10;```java&#10;public static void main(String[] args) {&#10;    sa.com.cloudsolutions.antikythera.agent.AntikytheraAgent.initialize();&#10;    // Continue with application logic&#10;}&#10;```&#10;This triggers `ByteBuddyAgent.install()` internally, obtaining an `Instrumentation` instance and installing transformations, then retransforms `java.lang.reflect.Field`.&#10;&#10;## Integration Contract&#10;Your participating application classes must:&#10;1. Declare a field named exactly `instanceInterceptor` (any visibility). Existence triggers instrumentation.&#10;2. The `instanceInterceptor` object must expose (directly or via inheritance) a field named `evaluator`.&#10;3. The `evaluator` object must provide a public or declared method `getField(String)` returning a Symbol-like object.&#10;4. The returned Symbol must provide a method `setValue(Object)`.&#10;&#10;Minimal sketch:&#10;```java&#10;class MySymbol { void setValue(Object v) { ... } }&#10;class MyEvaluator { MySymbol getField(String name) { ... } }&#10;class MyMethodInterceptor { MyEvaluator evaluator; }&#10;class MyDomainObject { MyMethodInterceptor instanceInterceptor; int counter; }&#10;```&#10;&#10;## Limitations &amp; Edge Cases&#10;- Static field updates via reflection are ignored (no target instance, no `instanceInterceptor`).&#10;- Bytecode hook only fires for writes executed inside *instance methods*; static methods are skipped (check uses `!isStatic`).&#10;- Injected callback passes `null` as the value; if concrete new value is required, `Support.afterSet` must re-fetch it (reflection or VarHandle) using the provided object &amp; field name.&#10;- The `Support` class is referenced but not present in this module; it is expected to reside on the target application's classpath (likely in `antikythera-common`). Ensure its binary name: `sa.com.cloudsolutions.antikythera.agent.Support`.&#10;- If a security manager (legacy) or restrictive module boundaries block `setAccessible(true)`, reflective advice may become a no-op.&#10;- Multiple successive writes in one method body each trigger a callback.&#10;&#10;## Performance Considerations&#10;- Per-write overhead: one static method call (bytecode instrumentation) plus whatever `Support.afterSet` does.&#10;- Reflective path adds hierarchy &amp; field lookups; mitigated by early exits and minimal branching.&#10;- No caching layer currently for field/method lookups. For high-frequency reflective writes, adding caches (e.g., `ConcurrentHashMap&lt;Class&lt;?&gt;, Field&gt;`) could help.&#10;&#10;## Security Considerations&#10;- Uses `setAccessible(true)` indiscriminately. In containerized or modularized environments, consider adding guards.&#10;- Swallows all exceptions in advice, which preserves stability but can conceal integration misconfiguration; add logging in controlled environments when debugging.&#10;&#10;## Testing&#10;Current test suite (`ReflectiveSetAdviceTest`) performs a focused unit test on `ReflectiveSetAdvice.after(...)` by:&#10;- Creating a mock evaluation engine &amp; symbol.&#10;- Simulating a reflective set of an `int` field.&#10;- Asserting the symbol receives value &amp; name.&#10;&#10;To run tests:&#10;```&#10;mvn test&#10;```&#10;&#10;Potential missing tests:&#10;- End-to-end integration validating bytecode injection by launching a test JVM with `-javaagent`.&#10;- Static field write scenarios.&#10;- Multiple hierarchy levels for `instanceInterceptor` and `evaluator` fields.&#10;&#10;## Extending the Agent&#10;Ideas:&#10;- Capture previous value (read before write) to enable change-diff notifications.&#10;- Include value type descriptors and generics metadata.&#10;- Add configuration via agent arguments (e.g., opt-in class patterns, logging verbosity) using `premain(String agentArgs, ...)`.&#10;- Provide caching for reflective lookups.&#10;- Support static field symbol updates (derive symbol scope differently).&#10;&#10;## Troubleshooting&#10;| Symptom | Possible Cause | Remedy |&#10;|---------|----------------|--------|&#10;| No callbacks occur | Class lacks `instanceInterceptor` field or loaded before agent without retransformation | Verify field name; ensure agent premain or call `initialize()` early |&#10;| `NoSuchMethodException: getField` in advice | Evaluator does not implement expected API | Implement or adapt evaluator contract |&#10;| `IllegalAccessException` during advice | Module boundaries or security manager | Open packages or adjust JVM args (`--add-opens`) |&#10;| Crash / linkage errors when instrumenting `java.lang.reflect.Field` | JDK version mismatch or unsupported changes | Verify JDK 21 compatibility; update Byte Buddy version |&#10;&#10;## Roadmap Ideas&#10;- Pluggable value propagation strategies.&#10;- Granular opt-out annotations instead of global marker field.&#10;- Structured event emission (e.g., to Flight Recorder or an event bus).&#10;- Observability metrics counters for write frequency.&#10;&#10;## License&#10;(Add license information here if/when a license file is introduced.)&#10;&#10;---&#10;Generated README documenting the current implementation status (commit context not embedded). Update as the integration contract evolves.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>