<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/sa/com/cloudsolutions/antikythera/agent/AntikytheraAgent.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/sa/com/cloudsolutions/antikythera/agent/AntikytheraAgent.java" />
              <option name="originalContent" value="package sa.com.cloudsolutions.antikythera.agent;&#10;&#10;import net.bytebuddy.agent.ByteBuddyAgent;&#10;import net.bytebuddy.agent.builder.AgentBuilder;&#10;import net.bytebuddy.asm.AsmVisitorWrapper;&#10;import net.bytebuddy.asm.Advice;&#10;import net.bytebuddy.description.field.FieldDescription;&#10;import net.bytebuddy.description.field.FieldList;&#10;import net.bytebuddy.description.method.MethodList;&#10;import net.bytebuddy.description.type.TypeDescription;&#10;import net.bytebuddy.dynamic.ClassFileLocator;&#10;import net.bytebuddy.implementation.Implementation;&#10;import net.bytebuddy.matcher.ElementMatcher;&#10;import net.bytebuddy.matcher.ElementMatchers;&#10;import net.bytebuddy.pool.TypePool;&#10;import net.bytebuddy.jar.asm.ClassVisitor;&#10;import net.bytebuddy.jar.asm.MethodVisitor;&#10;import net.bytebuddy.jar.asm.Opcodes;&#10;&#10;import java.lang.instrument.Instrumentation;&#10;import java.util.Collections;&#10;&#10;/**&#10; * Java agent that installs a Byte Buddy transformation to classes that declare a field named&#10; * &quot;instanceInterceptor&quot;. For such classes, after any successful field write (PUTFIELD/PUTSTATIC)&#10; * inside an instance method, we invoke Support.afterSet(this, fieldName, null).&#10; *&#10; * Additionally, we intercept reflective writes via java.lang.reflect.Field#set*(Object, ...)&#10; * and perform the same callback after successful completion.&#10; *&#10; * The agent can be installed via premain/agentmain or programmatically by calling initialize().&#10; */&#10;public class AntikytheraAgent {&#10;&#10;    public static void premain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    public static void agentmain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    /**&#10;     * Allows runtime installation without -javaagent by attaching a Byte Buddy agent to the current JVM&#10;     * and then registering our transformers on the returned Instrumentation.&#10;     */&#10;    public static void initialize() {&#10;        Instrumentation inst = ByteBuddyAgent.install();&#10;        install(inst);&#10;    }&#10;&#10;    private static void install(Instrumentation inst) {&#10;        ElementMatcher.Junction&lt;TypeDescription&gt; typeMatcher =&#10;                ElementMatchers.declaresField(ElementMatchers.named(&quot;instanceInterceptor&quot;));&#10;&#10;        try {&#10;            // Manually append ReflectiveSetAdvice to bootstrap classloader&#10;            ClassFileLocator locator = ClassFileLocator.ForClassLoader.of(AntikytheraAgent.class.getClassLoader());&#10;            byte[] adviceClass = locator.locate(ReflectiveSetAdvice.class.getName()).resolve();&#10;&#10;            // Create a temporary JAR file containing the advice class&#10;            java.io.File tempJar = java.io.File.createTempFile(&quot;antikythera-agent-advice&quot;, &quot;.jar&quot;);&#10;            tempJar.deleteOnExit();&#10;&#10;            try (java.util.jar.JarOutputStream jos = new java.util.jar.JarOutputStream(&#10;                    new java.io.FileOutputStream(tempJar))) {&#10;                java.util.jar.JarEntry entry = new java.util.jar.JarEntry(&#10;                        ReflectiveSetAdvice.class.getName().replace('.', '/') + &quot;.class&quot;);&#10;                jos.putNextEntry(entry);&#10;                jos.write(adviceClass);&#10;                jos.closeEntry();&#10;            }&#10;&#10;            // Add to bootstrap classloader&#10;            inst.appendToBootstrapClassLoaderSearch(new java.util.jar.JarFile(tempJar));&#10;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to inject ReflectiveSetAdvice into bootstrap classloader&quot;, e);&#10;        }&#10;&#10;        new AgentBuilder.Default()&#10;                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)&#10;                .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)&#10;                .with(AgentBuilder.TypeStrategy.Default.REDEFINE)&#10;                .ignore(ElementMatchers.none())&#10;                .type(typeMatcher)&#10;                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt;&#10;                        builder.visit(createFieldWriteHook()))&#10;                .type(ElementMatchers.named(&quot;java.lang.reflect.Field&quot;))&#10;                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt;&#10;                        builder.visit(Advice.to(ReflectiveSetAdvice.class).on(&#10;                                ElementMatchers.named(&quot;set&quot;)&#10;                                        .or(ElementMatchers.named(&quot;setBoolean&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setByte&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setChar&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setShort&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setInt&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setLong&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setFloat&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setDouble&quot;))&#10;                        )))&#10;                .installOn(inst);&#10;        try {&#10;            inst.retransformClasses(java.lang.reflect.Field.class);&#10;        } catch (Exception e) {&#10;            System.out.println(&quot;Failed to retransform Field: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private static AsmVisitorWrapper createFieldWriteHook() {&#10;        return new net.bytebuddy.asm.AsmVisitorWrapper.AbstractBase() {&#10;            @Override&#10;            public ClassVisitor wrap(TypeDescription instrumentedType,&#10;                                     ClassVisitor classVisitor,&#10;                                     Implementation.Context implementationContext,&#10;                                     TypePool typePool,&#10;                                     FieldList&lt;FieldDescription.InDefinedShape&gt; fields,&#10;                                     MethodList&lt;?&gt; methods,&#10;                                     int writerFlags,&#10;                                     int readerFlags) {&#10;                return new ClassVisitor(Opcodes.ASM9, classVisitor) {&#10;                    @Override&#10;                    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {&#10;                        MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);&#10;                        final boolean isStatic = (access &amp; Opcodes.ACC_STATIC) != 0;&#10;                        return new MethodVisitor(Opcodes.ASM9, mv) {&#10;                            @Override&#10;                            public void visitFieldInsn(int opcode, String owner, String fieldName, String fieldDesc) {&#10;                                super.visitFieldInsn(opcode, owner, fieldName, fieldDesc);&#10;                                if (!isStatic &amp;&amp; (opcode == Opcodes.PUTFIELD || opcode == Opcodes.PUTSTATIC)) {&#10;                                    super.visitVarInsn(Opcodes.ALOAD, 0);&#10;                                    super.visitLdcInsn(fieldName);&#10;                                    super.visitInsn(Opcodes.ACONST_NULL);&#10;                                    super.visitMethodInsn(&#10;                                            Opcodes.INVOKESTATIC,&#10;                                            &quot;sa/com/cloudsolutions/antikythera/agent/Support&quot;,&#10;                                            &quot;afterSet&quot;,&#10;                                            &quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,&#10;                                            false&#10;                                    );&#10;                                }&#10;                            }&#10;                        };&#10;                    }&#10;                };&#10;            }&#10;        };&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package sa.com.cloudsolutions.antikythera.agent;&#10;&#10;import net.bytebuddy.agent.ByteBuddyAgent;&#10;import net.bytebuddy.agent.builder.AgentBuilder;&#10;import net.bytebuddy.asm.Advice;&#10;import net.bytebuddy.dynamic.ClassFileLocator;&#10;import net.bytebuddy.matcher.ElementMatchers;&#10;&#10;import java.lang.instrument.Instrumentation;&#10;&#10;/**&#10; * Java agent that intercepts reflective field writes via java.lang.reflect.Field#set*(Object, ...)&#10; * and updates the corresponding Symbol in the EvaluationEngine if the target object has an&#10; * instanceInterceptor field.&#10; *&#10; * The agent can be installed via premain/agentmain or programmatically by calling initialize().&#10; */&#10;public class AntikytheraAgent {&#10;&#10;    public static void premain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    public static void agentmain(String agentArgs, Instrumentation inst) {&#10;        install(inst);&#10;    }&#10;&#10;    /**&#10;     * Allows runtime installation without -javaagent by attaching a Byte Buddy agent to the current JVM&#10;     * and then registering our transformers on the returned Instrumentation.&#10;     */&#10;    public static void initialize() {&#10;        Instrumentation inst = ByteBuddyAgent.install();&#10;        install(inst);&#10;    }&#10;&#10;    private static void install(Instrumentation inst) {&#10;        try {&#10;            // Manually append ReflectiveSetAdvice to bootstrap classloader&#10;            ClassFileLocator locator = ClassFileLocator.ForClassLoader.of(AntikytheraAgent.class.getClassLoader());&#10;            byte[] adviceClass = locator.locate(ReflectiveSetAdvice.class.getName()).resolve();&#10;&#10;            // Create a temporary JAR file containing the advice class&#10;            java.io.File tempJar = java.io.File.createTempFile(&quot;antikythera-agent-advice&quot;, &quot;.jar&quot;);&#10;            tempJar.deleteOnExit();&#10;&#10;            try (java.util.jar.JarOutputStream jos = new java.util.jar.JarOutputStream(&#10;                    new java.io.FileOutputStream(tempJar))) {&#10;                java.util.jar.JarEntry entry = new java.util.jar.JarEntry(&#10;                        ReflectiveSetAdvice.class.getName().replace('.', '/') + &quot;.class&quot;);&#10;                jos.putNextEntry(entry);&#10;                jos.write(adviceClass);&#10;                jos.closeEntry();&#10;            }&#10;&#10;            // Add to bootstrap classloader&#10;            inst.appendToBootstrapClassLoaderSearch(new java.util.jar.JarFile(tempJar));&#10;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;Failed to inject ReflectiveSetAdvice into bootstrap classloader&quot;, e);&#10;        }&#10;&#10;        new AgentBuilder.Default()&#10;                .with(AgentBuilder.RedefinitionStrategy.RETRANSFORMATION)&#10;                .with(AgentBuilder.InitializationStrategy.NoOp.INSTANCE)&#10;                .with(AgentBuilder.TypeStrategy.Default.REDEFINE)&#10;                .ignore(ElementMatchers.none())&#10;                // Only instrument java.lang.reflect.Field for reflective field sets&#10;                .type(ElementMatchers.named(&quot;java.lang.reflect.Field&quot;))&#10;                .transform((builder, typeDescription, classLoader, module, protectionDomain) -&gt;&#10;                        builder.visit(Advice.to(ReflectiveSetAdvice.class).on(&#10;                                ElementMatchers.named(&quot;set&quot;)&#10;                                        .or(ElementMatchers.named(&quot;setBoolean&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setByte&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setChar&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setShort&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setInt&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setLong&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setFloat&quot;))&#10;                                        .or(ElementMatchers.named(&quot;setDouble&quot;))&#10;                        )))&#10;                .installOn(inst);&#10;        try {&#10;            inst.retransformClasses(java.lang.reflect.Field.class);&#10;        } catch (Exception e) {&#10;            System.out.println(&quot;Failed to retransform Field: &quot; + e.getMessage());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>